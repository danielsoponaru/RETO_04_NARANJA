sidebarPanel(
sliderInput('ranking', label='Number of observations:', min=1, max=100, value= c(1,100)),
selectInput('variable', 'seleciona la variable', choices = c('acousticness', 'danceability')),
selelectInput("cluster", "Selecciona cluster:", choices = 1:5),  # assuming 5 clusters
actionButton("goButton", "Ejecutar")
),
mainPanel(
tabsetPanel(
tabPanel("Canciones", dataTableOutput("songs_table")),
tabPanel("Cluster", plotOutput("cluster_plot")),
tabPanel("Variable", plotOutput("var_plot"))
)
)
)
)
library(shiny)
df$cluster=as.factor(df$cluster)
ui=fluidPage(
titlePanel("Spotify TOP 2018"),
sidebarLayout(
sidebarPanel(
sliderInput('ranking', label='Number of observations:', min=1, max=100, value= c(1,100)),
selectInput('variable', 'seleciona la variable', choices = c('acousticness', 'danceability')),
selelectInput("cluster", "Selecciona cluster:", choices = 1:5),  # assuming 5 clusters
actionButton("goButton", "Ejecutar")
),
mainPanel(
tabsetPanel(
tabPanel("Canciones", dataTableOutput("songs_table")),
tabPanel("Cluster", plotOutput("cluster_plot")),
tabPanel("Variable", plotOutput("var_plot"))
)
)
)
)
ui=fluidPage(
titlePanel("Spotify TOP 2018"),
sidebarLayout(
sidebarPanel(
sliderInput('ranking', label='Number of observations:', min=1, max=100, value= c(1,100)),
selectInput('variable', 'seleciona la variable', choices = c('acousticness', 'danceability')),
selectInput("cluster", "Selecciona cluster:", choices = 1:5),  # assuming 5 clusters
actionButton("goButton", "Ejecutar")
),
mainPanel(
tabsetPanel(
tabPanel("Canciones", dataTableOutput("songs_table")),
tabPanel("Cluster", plotOutput("cluster_plot")),
tabPanel("Variable", plotOutput("var_plot"))
)
)
)
)
ui=fluidPage(
titlePanel("Spotify TOP 2018"),
sidebarLayout(
sidebarPanel(
sliderInput('ranking', label='Number of observations:', min=1, max=100, value= c(1,100)),
selectInput('variable', 'seleciona la variable', choices = c('acousticness', 'danceability')),
selectInput("cluster", "Selecciona cluster:", choices = 1:5),  # assuming 5 clusters
actionButton("goButton", "Ejecutar")
),
mainPanel(
tabsetPanel(
tabPanel("Canciones", dataTableOutput("songs_table")),
tabPanel("Cluster", plotOutput("cluster_plot")),
tabPanel("Variable", plotOutput("var_plot"))
)
)
)
)
library(DT)
ui = fluidPage(
titlePanel("Spotify TOP 2018"),
sidebarLayout(
sidebarPanel(
sliderInput('ranking', label = 'Posición en el ranking:', min = 1, max = 100, value = c(1, 100)),
selectInput('variable', 'Selecciona la variable', choices = c('acousticness', 'danceability')),
selectInput("cluster", "Selecciona cluster:", choices = 1:5),
actionButton("goButton", "Ejecutar")
),
mainPanel(
tabsetPanel(
tabPanel("Canciones", DT::DTOutput("songs_table")),
tabPanel("Cluster", plotOutput("cluster_plot")),
tabPanel("Variable", plotOutput("var_plot"))
)
)
)
)
ui
View(ui)
plot(ui)
ui = fluidPage(
titlePanel("Spotify TOP 2018"),
sidebarLayout(
sidebarPanel(
sliderInput('ranking', label = 'Posición en el ranking:', min = 1, max = 100, value = c(1, 100)),
selectInput('variable', 'Selecciona la variable', choices = c('acousticness', 'danceability')),
selectInput("cluster", "Selecciona cluster:", choices = 1:5),
actionButton("goButton", "Ejecutar")
),
mainPanel(
tabsetPanel(
tabPanel("Canciones", DT::DTOutput("songs_table")),
tabPanel("Cluster", plotOutput("cluster_plot")),
tabPanel("Variable", plotOutput("var_plot"))
)
)
)
)
ui
ui = fluidPage(
titlePanel("Spotify TOP 2018"),
sidebarLayout(
sidebarPanel(
sliderInput('ranking', label = 'Posición en el ranking:', min = 1, max = 100, value = c(1, 100)),
selectInput('variable', 'Selecciona la variable', choices = c('acousticness', 'danceability')),
selectInput("cluster", "Selecciona cluster:", choices = 1:5),
actionButton("goButton", "Ejecutar")
),
mainPanel(
tabsetPanel(
tabPanel("Canciones", DT::DTOutput("songs_table")),
tabPanel("Cluster", plotOutput("cluster_plot")),
tabPanel("Variable", plotOutput("var_plot"))
)
)
)
)
shinyApp(ui=ui, server=server)
shinyApp(ui=ui, server = server)
maestrostr <- readRDS("Datos/maestroestr.RDS")
objetivos <- readRDS("Datos/objetivos.RDS")
tickets_enc <- readRDS("Datos/tickets_enc.RDS")
matriz=readRDS("Datos/matriz.RDS")
# Cargar librerías necesarias
library(tidyverse)
maestrostr <- readRDS("Datos/maestroestr.RDS")
objetivos <- readRDS("Datos/objetivos.RDS")
maestrostr <- readRDS("Datos/maestroestr.RDS")
# 1. Cargar datos
data <- readRDS("matriz.RDS")
objetivos <- readRDS("objetivos.RDS")
clientes_objetivo <- objetivos$objetivo2$obj
productos <- readRDS("maestroestr.RDS")
#  Vector con los códigos de los 20 productos en oferta (reemplaza con los reales si hace falta)
productos_en_oferta <- c("X12650103", "X01027405", "X05030101", "X05030102", "X01012310",
"X11040303", "X08230125", "X01201505", "X05040180", "X01201005", "X09070103",
"X04200505", "X01026410", "X05040181", "X04201005", "X12670111", "X08100903",
"X01013315", "X01027205", "X12650101"
)
# 2. Preparar la matriz
matriz <- replace(data, is.na(data), 0)
matriz_dense <- as.matrix(matriz)
matriz_sparse <- as(Matrix(matriz_dense, sparse = TRUE), "dgCMatrix")
# Cargar librerías necesarias
library(recommenderlab)
library(rsparse)
library(Matrix)
library(dplyr)
matriz_sparse <- as(Matrix(matriz_dense, sparse = TRUE), "dgCMatrix")
# 3. Entrenar modelo ALS
modelo_ALS <- WRMF$new(rank = 30, lambda = 0.1, feedback = "implicit")
modelo_ALS$fit_transform(matriz_sparse)
# 4. Recomendaciones para todos los clientes
id_usuarios <- 1:nrow(matriz)  # Todos los clientes
# 5. Predecir top 50 productos por cliente
predicciones <- modelo_ALS$predict(matriz_sparse[id_usuarios, , drop = FALSE], k = 50)
# 6. Filtrar predicciones solo a productos en oferta
cols_oferta <- which(colnames(matriz) %in% productos_en_oferta)
filtrar_oferta <- function(indices, cols_oferta) {
inter <- intersect(indices, cols_oferta)
if (length(inter) == 0) return(NA)
return(inter[1])
}
recomendaciones_filtradas <- sapply(predicciones, filtrar_oferta, cols_oferta = cols_oferta)
productos_recomendados <- colnames(matriz)[recomendaciones_filtradas]
# 7. Reemplazar NA con producto en oferta más popular
popularidad <- colSums(matriz_sparse)[productos_en_oferta]
producto_popular <- names(sort(popularidad, decreasing = TRUE))[1]
productos_recomendados[is.na(productos_recomendados)] <- producto_popular
# 8. Construir resultado final
resultado <- data.frame(
cliente = rownames(matriz)[id_usuarios],
producto_recomendado = productos_recomendados
)
# Asegura formato correcto
resultado$producto_recomendado <- as.character(resultado$producto_recomendado)
productos$cod_est <- as.character(productos$cod_est)
# Elimina prefijo "X" si existe
resultado$producto_recomendado <- sub("^X", "", resultado$producto_recomendado)
productos$cod_est <- sub("^X", "", productos$cod_est)
# Hacer merge con tabla de productos para obtener descripción
resultado_final <- merge(resultado,
productos,
by.x = "producto_recomendado",
by.y = "cod_est",
all.x = TRUE)
# Seleccionar columnas finales
resultado_final <- resultado_final[, c("cliente", "producto_recomendado", "descripcion")]
# Ver resultado
print(resultado_final)
levels(as.factor(resultado_final$descripcion))
ct=resultado_final%>%
group_by(descripcion)%>%
count()
platanos=matriz[,"X01012310"]
View(matriz)
colnames(matriz)
h=colnames(matriz)
j=h=="X01012310"
j
h=colnames(matriz)
h
j=h=="X01012310"
j
h
platanos=matriz[,"X01012310"]
"X01012310" %in% colnames(matriz)
grep("01012310", colnames(matriz), value = TRUE)
platanos
platanos = matriz[, "X01012310", drop = FALSE]
View(platanos)
max(platanos)
summary(platanos)
ct=resultado_final%>%
group_by(descripcion)%>%
count()
View(ct)
View(productos)
View(productos)
calabacines= matriz[, "X01026410", drop = FALSE]
View(calabacines)
summary(calabacines)
summary(platanos)
View(platanos)
library(recommenderlab)
library(rsparse)
library(Matrix)
library(dplyr)
# 1. Cargar datos
data <- readRDS("matriz.RDS")
objetivos <- readRDS("objetivos.RDS")
clientes_objetivo <- objetivos$objetivo2$obj
productos <- readRDS("maestroestr.RDS")
#  Vector con los códigos de los 20 productos en oferta (reemplaza con los reales si hace falta)
productos_en_oferta <- c("X12650103", "X01027405", "X05030101", "X05030102", "X01012310",
"X11040303", "X08230125", "X01201505", "X05040180", "X01201005", "X09070103",
"X04200505", "X01026410", "X05040181", "X04201005", "X12670111", "X08100903",
"X01013315", "X01027205", "X12650101"
)
# 2. Preparar la matriz
matriz <- replace(data, is.na(data), 0)
matriz[matriz > 15] <- 0
matriz_dense <- as.matrix(matriz)
matriz_sparse <- as(Matrix(matriz_dense, sparse = TRUE), "dgCMatrix")
# 3. Entrenar modelo ALS
modelo_ALS <- WRMF$new(rank = 30, lambda = 0.1, feedback = "implicit")
modelo_ALS$fit_transform(matriz_sparse)
# 4. Recomendaciones para todos los clientes
id_usuarios <- 1:nrow(matriz)  # Todos los clientes
# 5. Predecir top 50 productos por cliente
predicciones <- modelo_ALS$predict(matriz_sparse[id_usuarios, , drop = FALSE], k = 50)
# 6. Filtrar predicciones solo a productos en oferta
cols_oferta <- which(colnames(matriz) %in% productos_en_oferta)
filtrar_oferta <- function(indices, cols_oferta) {
inter <- intersect(indices, cols_oferta)
if (length(inter) == 0) return(NA)
return(inter[1])
}
recomendaciones_filtradas <- sapply(predicciones, filtrar_oferta, cols_oferta = cols_oferta)
productos_recomendados <- colnames(matriz)[recomendaciones_filtradas]
# 7. Reemplazar NA con producto en oferta más popular
popularidad <- colSums(matriz_sparse)[productos_en_oferta]
producto_popular <- names(sort(popularidad, decreasing = TRUE))[1]
productos_recomendados[is.na(productos_recomendados)] <- producto_popular
# 8. Construir resultado final
resultado <- data.frame(
cliente = rownames(matriz)[id_usuarios],
producto_recomendado = productos_recomendados
)
# Asegura formato correcto
resultado$producto_recomendado <- as.character(resultado$producto_recomendado)
productos$cod_est <- as.character(productos$cod_est)
# Elimina prefijo "X" si existe
resultado$producto_recomendado <- sub("^X", "", resultado$producto_recomendado)
productos$cod_est <- sub("^X", "", productos$cod_est)
# Hacer merge con tabla de productos para obtener descripción
resultado_final <- merge(resultado,
productos,
by.x = "producto_recomendado",
by.y = "cod_est",
all.x = TRUE)
# Seleccionar columnas finales
resultado_final <- resultado_final[, c("cliente", "producto_recomendado", "descripcion")]
# Ver resultado
print(resultado_final)
levels(as.factor(resultado_final$descripcion))
ct=resultado_final%>%
group_by(descripcion)%>%
count()
View(ct)
platanos = matriz[, "X01012310", drop = FALSE]
summary(platanos)
calabacines= matriz[, "X01026410", drop = FALSE]
summary(calabacines)
matriz[matriz > 10] <- 0
matriz_dense <- as.matrix(matriz)
matriz_sparse <- as(Matrix(matriz_dense, sparse = TRUE), "dgCMatrix")
# 3. Entrenar modelo ALS
modelo_ALS <- WRMF$new(rank = 30, lambda = 0.1, feedback = "implicit")
modelo_ALS$fit_transform(matriz_sparse)
# 4. Recomendaciones para todos los clientes
id_usuarios <- 1:nrow(matriz)  # Todos los clientes
# 5. Predecir top 50 productos por cliente
predicciones <- modelo_ALS$predict(matriz_sparse[id_usuarios, , drop = FALSE], k = 50)
# 6. Filtrar predicciones solo a productos en oferta
cols_oferta <- which(colnames(matriz) %in% productos_en_oferta)
filtrar_oferta <- function(indices, cols_oferta) {
inter <- intersect(indices, cols_oferta)
if (length(inter) == 0) return(NA)
return(inter[1])
}
recomendaciones_filtradas <- sapply(predicciones, filtrar_oferta, cols_oferta = cols_oferta)
productos_recomendados <- colnames(matriz)[recomendaciones_filtradas]
# 7. Reemplazar NA con producto en oferta más popular
popularidad <- colSums(matriz_sparse)[productos_en_oferta]
producto_popular <- names(sort(popularidad, decreasing = TRUE))[1]
productos_recomendados[is.na(productos_recomendados)] <- producto_popular
# 8. Construir resultado final
resultado <- data.frame(
cliente = rownames(matriz)[id_usuarios],
producto_recomendado = productos_recomendados
)
# Asegura formato correcto
resultado$producto_recomendado <- as.character(resultado$producto_recomendado)
productos$cod_est <- as.character(productos$cod_est)
# Elimina prefijo "X" si existe
resultado$producto_recomendado <- sub("^X", "", resultado$producto_recomendado)
productos$cod_est <- sub("^X", "", productos$cod_est)
# Hacer merge con tabla de productos para obtener descripción
resultado_final <- merge(resultado,
productos,
by.x = "producto_recomendado",
by.y = "cod_est",
all.x = TRUE)
# Seleccionar columnas finales
resultado_final <- resultado_final[, c("cliente", "producto_recomendado", "descripcion")]
# Ver resultado
print(resultado_final)
levels(as.factor(resultado_final$descripcion))
ct=resultado_final%>%
group_by(descripcion)%>%
count()
platanos = matriz[, "X01012310", drop = FALSE]
summary(platanos)
calabacines= matriz[, "X01026410", drop = FALSE]
summary(calabacines)
View(ct)
zanahorias= matriz[, "X01027405", drop = FALSE]
summary(zanahorias)
ct <- resultado_final %>%
count(descripcion, sort = TRUE)
View(resultado_final)
View(matriz)
# 5. Predecir top 50 productos por cliente
predicciones <- modelo_ALS$predict(matriz_sparse[id_usuarios, , drop = FALSE], k = 1)
# 6. Filtrar predicciones solo a productos en oferta
cols_oferta <- which(colnames(matriz) %in% productos_en_oferta)
filtrar_oferta <- function(indices, cols_oferta) {
inter <- intersect(indices, cols_oferta)
if (length(inter) == 0) return(NA)
return(inter[1])
}
recomendaciones_filtradas <- sapply(predicciones, filtrar_oferta, cols_oferta = cols_oferta)
productos_recomendados <- colnames(matriz)[recomendaciones_filtradas]
# 7. Reemplazar NA con producto en oferta más popular
popularidad <- colSums(matriz_sparse)[productos_en_oferta]
producto_popular <- names(sort(popularidad, decreasing = TRUE))[1]
productos_recomendados[is.na(productos_recomendados)] <- producto_popular
# 8. Construir resultado final
resultado <- data.frame(
cliente = rownames(matriz)[id_usuarios],
producto_recomendado = productos_recomendados
)
# Asegura formato correcto
resultado$producto_recomendado <- as.character(resultado$producto_recomendado)
productos$cod_est <- as.character(productos$cod_est)
# Elimina prefijo "X" si existe
resultado$producto_recomendado <- sub("^X", "", resultado$producto_recomendado)
productos$cod_est <- sub("^X", "", productos$cod_est)
# Hacer merge con tabla de productos para obtener descripción
resultado_final <- merge(resultado,
productos,
by.x = "producto_recomendado",
by.y = "cod_est",
all.x = TRUE)
# Seleccionar columnas finales
resultado_final <- resultado_final[, c("cliente", "producto_recomendado", "descripcion")]
# Ver resultado
print(resultado_final)
levels(as.factor(resultado_final$descripcion))
ct <- resultado_final %>%
count(descripcion, sort = TRUE)
View(ct)
# 7. Fallback: sorteo ponderado por popularidad
popularidad <- colSums(matriz_sparse)[productos_en_oferta]
set.seed(123)
fallbacks <- sample(
productos_en_oferta,
sum(is.na(recomendaciones_filtradas)),
replace = TRUE,
prob = popularidad
)
# Convertir a nombres de producto
productos_recomendados <- colnames(matriz)[recomendaciones_filtradas]
productos_recomendados[is.na(productos_recomendados)] <- fallbacks
# 8. Construir resultado final
resultado <- data.frame(
cliente = rownames(matriz),
producto_recomendado = productos_recomendados
)
# Limpieza de formatos
resultado$producto_recomendado <- as.character(resultado$producto_recomendado)
productos$cod_est <- as.character(productos$cod_est)
resultado$producto_recomendado <- sub("^X", "", resultado$producto_recomendado)
productos$cod_est <- sub("^X", "", productos$cod_est)
# Merge para obtener descripción del producto
resultado_final <- merge(resultado,
productos,
by.x = "producto_recomendado",
by.y = "cod_est",
all.x = TRUE)
# Selección de columnas finales
resultado_final <- resultado_final[, c("cliente", "producto_recomendado", "descripcion")]
# Ver resumen de recomendaciones
ct <- resultado_final %>%
group_by(descripcion) %>%
count()
# Mostrar tabla resumen
print(ct)
library(dplyr)
library(lubridate)
library(ggplot2)
#Cargar datos
maestroestr<-readRDS("Datos/maestroestr.RDS")
objetivos<-readRDS("Datos/objetivos.RDS")
tickets_enc<-readRDS("Datos/tickets_enc.RDS")
maestroestr #codigos de productos
tickets_enc #productos que ha adquirido cada cliente
#Cargar datos
maestroestr<-readRDS("Datos/maestroestr.RDS")
objetivos<-readRDS("Datos/objetivos.RDS")
tickets_enc<-readRDS("Datos/tickets_enc.RDS")
#Cargar librarias necesarias
library(dplyr)
library(lubridate)
library(ggplot2)
#Cargar datos
maestroestr<-readRDS("Datos/maestroestr.RDS")
objetivos<-readRDS("Datos/objetivos.RDS")
tickets_enc<-readRDS("Datos/tickets_enc.RDS")
#Cargar datos
maestroestr<-readRDS("Datos/maestroestr.RDS")
objetivos<-readRDS("Datos/objetivos.RDS")
tickets_enc<-readRDS("Datos/tickets_enc.RDS")
#Cargar datos
maestroestr<-readRDS("Datos/maestroestr.RDS")
objetivos<-readRDS("Datos/objetivos.RDS")
#Cargar datos
maestroestr<-readRDS("Datos/maestroestr.RDS")
#Cargar datos
maestroestr<-readRDS("maestroestr.RDS")
objetivos<-readRDS("objetivos.RDS")
tickets_enc<-readRDS("tickets_enc.RDS")
maestroestr #codigos de productos
tickets_enc #productos que ha adquirido cada cliente
options(scipen = 999)
#Examinar datos y tipos de columnas
str(maestroestr)
str(tickets_enc)
summary(maestroestr)
summary(tickets_enc)
colnames(maestroestr)
colnames(tickets_enc)
dim(maestroestr)
dim(tickets_enc)
#Ajustar tipos de columnas
tickets_enc$dia<- ymd(tickets_enc$dia)
tickets_enc$cod_est<- as.numeric(tickets_enc$cod_est)
tickets_enc$id_cliente_enc<- as.character(tickets_enc$id_cliente_enc)
maestroestr$cod_est<- as.numeric(maestroestr$cod_est)
#Comprobar
str(tickets_enc) #todos los tipos de columnas son correctos
#GRAFICO 1: Histograma de cuantos articulos se suelen llevar en cada compra (por ticket)
tickets_enc1<- tickets_enc %>%
group_by(num_ticket, id_cliente_enc) %>%
summarise(ArticulosPorCompra = n()) %>%
arrange(desc(ArticulosPorCompra))
grafico1<- ggplot(tickets_enc1, aes(x = ArticulosPorCompra)) +
geom_histogram(color = "lightblue4", fill = "lightblue", binwidth = 1) +
labs(title = "Cantidad de articulos que se llevan por compra",
y = "Cantidad de tickets",
x = "Articulos por ticket(compra)") +
theme_minimal()
grafico1<- ggplot(tickets_enc1, aes(x = ArticulosPorCompra)) +
geom_histogram(color = "lightblue4", fill = "lightblue", binwidth = 1) +
labs(title = "Cantidad de articulos que se llevan por compra",
y = "Cantidad de tickets",
x = "Articulos por ticket(compra)") +
theme_minimal()
