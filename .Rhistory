<<<<<<< HEAD
productos_ultimo_ticket <- ultimos_tickets %>%
filter(id_cliente_enc == cliente) %>%
pull(cod_est)
# Mantener solo productos que están en la matriz de productos
productos_validos <- intersect(productos_ultimo_ticket, productos_matriz)
if (length(productos_validos) > 0) {
# Marcar con 1 en la matriz de exclusión
not_recommend_df[cliente, productos_validos] <- 1
cat("Cliente", cliente, "tiene", length(productos_validos), "productos marcados como no recomendables\n")
} else {
cat("Cliente", cliente, "no tiene productos para excluir\n")
}
}
# Convertir la matriz de exclusión a formato sparse
not_recommend_matrix <- as(not_recommend_df, "dgCMatrix")
# 16. Predecir recomendaciones para clientes objetivo,
# excluyendo productos comprados recientemente
preds_o4 <- modelo_wrmf_o4$predict(
matriz_reducida[clientes_en_matriz, ],
k = 1,                                  # Solo la mejor recomendación por cliente
not_recommend = not_recommend_matrix[clientes_en_matriz, ]  # Productos a excluir
)
# Extraer ids de productos recomendados (primer recomendación) y asignar nombres de clientes
predicciones <- as.data.frame(attr(preds_o4, "ids"))
predicciones$clientes <- rownames(predicciones)
rownames(predicciones) <- NULL
# Seleccionar columnas relevantes: cliente y producto recomendado
predicciones <- predicciones %>%
select(clientes, V1)
# Hacer join para obtener descripción de productos desde tabla maestro
predicciones <- predicciones %>%
left_join(maestro, by = c("V1" = "cod_est"))
# Renombrar columnas para mayor claridad
colnames(predicciones) <- c("clientes", "cod_prod", "descripcion")
predicciones
# Renombrar columnas para mayor claridad
colnames(predicciones) <- c("CLIENTES", "COD_PRODUCTO", "DESCRIPCION")
predicciones
library(tidyverse)
library(lubridate)
library(rsparse)
library(dplyr)
library(Matrix)
# 1. Cargar datos desde archivos RDS
maestro <- readRDS("maestroestr.RDS")
objetivos <- readRDS("objetivos.RDS")
tickets <- readRDS("tickets_enc.RDS")
matriz_reducida <- readRDS("MatrizSuperReducida.RDS")
dim(matriz_reducida)
library(tidyverse)
library(lubridate)
library(rsparse)
library(dplyr)
library(Matrix)
# 1. Cargar datos desde archivos RDS
maestro <- readRDS("maestroestr.RDS")
objetivos <- readRDS("objetivos.RDS")
tickets <- readRDS("tickets_enc.RDS")
matriz_reducida <- readRDS("MatrizSuperReducida.RDS")
library(tidyverse)
library(lubridate)
library(rsparse)
library(dplyr)
library(Matrix)
# 1. Cargar datos desde archivos RDS
maestro <- readRDS("maestroestr.RDS")
objetivos <- readRDS("objetivos.RDS")
tickets <- readRDS("tickets_enc.RDS")
matriz_reducida <- readRDS("MatrizSuperReducida.RDS")
# 3. Extraer clientes que forman parte del objetivo 4
obj4 <- objetivos[[4]]$obj
# Limpiar nombres de columnas de la matriz para eliminar un carácter inicial no deseado
colnames(matriz_reducida) <- sub("^.", "", colnames(matriz_reducida))
# Filtrar la matriz solo para los clientes del objetivo 4
matriz_sparse_filt <- matriz_reducida[rownames(matriz_reducida) %in% obj4, ]
# Convertir matrices a formato sparse para optimizar cálculos
matriz_sparse_filt <- as(matriz_sparse_filt, "dgCMatrix")
matriz_reducida <- as(matriz_reducida, "dgCMatrix")
# 1. Cargar datos desde archivos RDS
maestro <- readRDS("maestroestr.RDS")
objetivos <- readRDS("objetivos.RDS")
tickets <- readRDS("tickets_enc.RDS")
matriz_reducida <- readRDS("MatrizSuperReducida.RDS")
View(matriz_reducida)
matriz_reducida <- as(matriz_reducida, "dgCMatrix")
matriz_reducida <- as(matriz_reducida, "matrix")
# 1. Cargar datos desde archivos RDS
maestro <- readRDS("maestroestr.RDS")
objetivos <- readRDS("objetivos.RDS")
tickets <- readRDS("tickets_enc.RDS")
matriz_reducida <- readRDS("MatrizSuperReducida.RDS")
matriz_reducida <- as(matriz_reducida, "matrix")
matriz_reducida <- as(matriz_reducida, "dgCMatrix")
# 3. Extraer clientes que forman parte del objetivo 4
obj4 <- objetivos[[4]]$obj
# Limpiar nombres de columnas de la matriz para eliminar un carácter inicial no deseado
colnames(matriz_reducida) <- sub("^.", "", colnames(matriz_reducida))
# Filtrar la matriz solo para los clientes del objetivo 4
matriz_sparse_filt <- matriz_reducida[rownames(matriz_reducida) %in% obj4, ]
# Convertir matrices a formato sparse para optimizar cálculos
matriz_sparse_filt <- as(matriz_sparse_filt, "dgCMatrix")
matriz_reducida <- as(matriz_reducida, "dgCMatrix")
matriz_reducida@x[matriz_reducida@x >= 1] <- 1
matriz_reducida
View(matriz_reducida)
View(matriz_reducida)
library(tidyverse)
library(lubridate)
library(rsparse)
library(dplyr)
library(Matrix)
# 1. Cargar datos desde archivos RDS
maestro <- readRDS("maestroestr.RDS")
objetivos <- readRDS("objetivos.RDS")
tickets <- readRDS("tickets_enc.RDS")
matriz_reducida <- readRDS("MatrizSuperReducida.RDS")
matriz_df[is.na(matriz_df)] <- 0
matriz_reducida[is.na(matriz_reducida)] <- 0
View(matriz_reducida)
matriz_reducida <- as(matriz_reducida, "matrix")
matriz_reducida <- as(matriz_reducida, "dgCMatrix")
# 3. Extraer clientes que forman parte del objetivo 4
obj4 <- objetivos[[4]]$obj
# Limpiar nombres de columnas de la matriz para eliminar un carácter inicial no deseado
colnames(matriz_reducida) <- sub("^.", "", colnames(matriz_reducida))
# Filtrar la matriz solo para los clientes del objetivo 4
matriz_sparse_filt <- matriz_reducida[rownames(matriz_reducida) %in% obj4, ]
# Convertir matrices a formato sparse para optimizar cálculos
matriz_sparse_filt <- as(matriz_sparse_filt, "dgCMatrix")
matriz_reducida <- as(matriz_reducida, "dgCMatrix")
matriz_reducida@x[matriz_reducida@x >= 1] <- 1
matriz_reducida
library(tidyverse)
library(lubridate)
library(rsparse)
library(dplyr)
library(Matrix)
# 1. Cargar datos desde archivos RDS
maestro <- readRDS("maestroestr.RDS")
objetivos <- readRDS("objetivos.RDS")
tickets <- readRDS("tickets_enc.RDS")
matriz_reducida <- readRDS("MatrizSuperReducida.RDS")
# Como carga dataframe convertimos los NAs en 0 y cambio el formato
matriz_reducida[is.na(matriz_reducida)] <- 0
matriz_reducida <- as(matriz_reducida, "matrix")
matriz_reducida <- as(matriz_reducida, "dgCMatrix")
matriz_reducida@x[matriz_reducida@x >= 1] <- 1
# 3. Extraer clientes que forman parte del objetivo 4
obj4 <- objetivos[[4]]$obj
# Limpiar nombres de columnas de la matriz para eliminar un carácter inicial no deseado
colnames(matriz_reducida) <- sub("^.", "", colnames(matriz_reducida))
# Filtrar la matriz solo para los clientes del objetivo 4
matriz_sparse_filt <- matriz_reducida[rownames(matriz_reducida) %in% obj4, ]
# Convertir matrices a formato sparse para optimizar cálculos
matriz_sparse_filt <- as(matriz_sparse_filt, "dgCMatrix")
matriz_reducida <- as(matriz_reducida, "dgCMatrix")
# 4. Filtrar tickets solo para clientes del objetivo 4 y convertir fechas a formato Date
tickets_filtrados <- tickets %>%
filter(id_cliente_enc %in% obj4) %>%
mutate(fecha = ymd(dia))
# 5. Obtener el último ticket de compra por cada cliente (más reciente)
ultimos_tickets <- tickets_filtrados %>%
group_by(id_cliente_enc) %>%
filter(fecha == max(fecha)) %>%
ungroup()
# 8. Verificar que los clientes objetivo estén presentes en la matriz de interacciones
clientes_en_matriz <- intersect(obj4, rownames(matriz_reducida))
length(clientes_en_matriz)
# 10. Inicializar y entrenar modelo WRMF para recomendaciones con parámetros dados
modelo_wrmf_o4 <- WRMF$new(rank = 10L,
lambda = 0.1,
feedback = 'implicit')
modelo_wrmf_o4$fit_transform(matriz_reducida,
n_iter = 1000L,
convergence_tol = 1e-6)
# 11. Obtener lista de todos los productos en la matriz
productos_matriz <- colnames(matriz_reducida)
# 14. Crear matriz para marcar productos que no deben recomendarse (los ya comprados últimamente)
not_recommend_df <- matrix(0,
nrow = nrow(matriz_reducida),
ncol = ncol(matriz_reducida))
rownames(not_recommend_df) <- rownames(matriz_reducida)
colnames(not_recommend_df) <- productos_matriz
# 15. Para cada cliente, marcar con 1 los productos de su último ticket para excluirlos de recomendaciones
for (cliente in clientes_en_matriz) {
# Extraer productos comprados en el último ticket del cliente
productos_ultimo_ticket <- ultimos_tickets %>%
filter(id_cliente_enc == cliente) %>%
pull(cod_est)
# Mantener solo productos que están en la matriz de productos
productos_validos <- intersect(productos_ultimo_ticket, productos_matriz)
if (length(productos_validos) > 0) {
# Marcar con 1 en la matriz de exclusión
not_recommend_df[cliente, productos_validos] <- 1
cat("Cliente", cliente, "tiene", length(productos_validos), "productos marcados como no recomendables\n")
} else {
cat("Cliente", cliente, "no tiene productos para excluir\n")
}
}
# Convertir la matriz de exclusión a formato sparse
not_recommend_matrix <- as(not_recommend_df, "dgCMatrix")
# 16. Predecir recomendaciones para clientes objetivo,
# excluyendo productos comprados recientemente
preds_o4 <- modelo_wrmf_o4$predict(
matriz_reducida[clientes_en_matriz, ],
k = 1,                                  # Solo la mejor recomendación por cliente
not_recommend = not_recommend_matrix[clientes_en_matriz, ]  # Productos a excluir
)
# 16. Predecir recomendaciones para clientes objetivo,
# excluyendo productos comprados recientemente
preds_o4 <- modelo_wrmf_o4$predict(
matriz_reducida[clientes_en_matriz, ],
k = 1,
not_recommend = not_recommend_matrix[clientes_en_matriz, ]
)
# Extraer ids de productos recomendados (primer recomendación) y asignar nombres de clientes
predicciones <- as.data.frame(attr(preds_o4, "ids"))
predicciones$clientes <- rownames(predicciones)
rownames(predicciones) <- NULL
# Seleccionar columnas relevantes: cliente y producto recomendado
predicciones <- predicciones %>%
select(clientes, V1)
# Hacer join para obtener descripción de productos desde tabla maestro
predicciones <- predicciones %>%
left_join(maestro, by = c("V1" = "cod_est"))
# Renombrar columnas para mayor claridad
colnames(predicciones) <- c("CLIENTES", "COD_PRODUCTO", "DESCRIPCION")
predicciones
matriz_reducida[clientes_en_matriz, ]
matriz_reducida[clientes_en_matriz, ]
ultimos_tickets
View(ultimos_tickets)
library(tidyverse)
library(lubridate)
library(rsparse)
library(dplyr)
library(Matrix)
# 1. Cargar datos desde archivos RDS
maestro <- readRDS("maestroestr.RDS")
objetivos <- readRDS("objetivos.RDS")
tickets <- readRDS("tickets_enc.RDS")
matriz_reducida <- readRDS("MatrizSuperReducida.RDS")
# Como carga dataframe convertimos los NAs en 0 y cambio el formato
matriz_reducida[is.na(matriz_reducida)] <- 0
matriz_reducida <- as(matriz_reducida, "matrix")
matriz_reducida <- as(matriz_reducida, "dgCMatrix")
matriz_reducida@x[matriz_reducida@x >= 1] <- 1
# -------------------------------------------
# PREPARACIÓN DE DATOS PARA EL OBJETIVO 4
# -------------------------------------------
# 3. Extraer clientes que forman parte del objetivo 4
obj4 <- objetivos[[4]]$obj
# Limpiar nombres de columnas de la matriz para eliminar un carácter inicial no deseado
colnames(matriz_reducida) <- sub("^.", "", colnames(matriz_reducida))
# Filtrar la matriz solo para los clientes del objetivo 4
matriz_sparse_filt <- matriz_reducida[rownames(matriz_reducida) %in% obj4, ]
# Convertir matrices a formato sparse para optimizar cálculos
matriz_sparse_filt <- as(matriz_sparse_filt, "dgCMatrix")
matriz_reducida <- as(matriz_reducida, "dgCMatrix")
# 4. Filtrar tickets solo para clientes del objetivo 4 y convertir fechas a formato Date
tickets_filtrados <- tickets %>%
filter(id_cliente_enc %in% obj4) %>%
mutate(fecha = ymd(dia))
# 5. Obtener el último ticket de compra por cada cliente (más reciente)
ultimos_tickets <- tickets_filtrados %>%
group_by(id_cliente_enc) %>%
filter(fecha == max(fecha)) %>%
ungroup()
View(ultimos_tickets)
View(tickets_filtrados)
tickets
View(tickets_filtrados)
ultimos_tickets <- tickets_filtrados %>%
group_by(id_cliente_enc) %>%
filter(fecha == max(fecha))
View(ultimos_tickets)
# 14. Crear matriz para marcar productos que no deben recomendarse (los ya comprados últimamente)
not_recommend_df <- matrix(0,
nrow = nrow(matriz_reducida),
ncol = ncol(matriz_reducida))
rownames(not_recommend_df) <- rownames(matriz_reducida)
colnames(not_recommend_df) <- productos_matriz
# 15. Para cada cliente, marcar con 1 los productos de su último ticket para excluirlos de recomendaciones
for (cliente in clientes_en_matriz) {
# Extraer productos comprados en el último ticket del cliente
productos_ultimo_ticket <- ultimos_tickets %>%
filter(id_cliente_enc == cliente) %>%
pull(cod_est)
# Mantener solo productos que están en la matriz de productos
productos_validos <- intersect(productos_ultimo_ticket, productos_matriz)
if (length(productos_validos) > 0) {
# Marcar con 1 en la matriz de exclusión
not_recommend_df[cliente, productos_validos] <- 1
cat("Cliente", cliente, "tiene", length(productos_validos), "productos marcados como no recomendables\n")
} else {
cat("Cliente", cliente, "no tiene productos para excluir\n")
}
}
# Convertir la matriz de exclusión a formato sparse
not_recommend_matrix <- as(not_recommend_df, "dgCMatrix")
not_recommend_matrix
dim(not_recommend_matrix)
library(tidyverse)
library(lubridate)
library(rsparse)
library(dplyr)
library(Matrix)
# 1. Cargar datos desde archivos RDS
maestro <- readRDS("maestroestr.RDS")
objetivos <- readRDS("objetivos.RDS")
tickets <- readRDS("tickets_enc.RDS")
matriz_reducida <- readRDS("MatrizSuperReducida.RDS")
# Como carga dataframe convertimos los NAs en 0 y cambio el formato
matriz_reducida[is.na(matriz_reducida)] <- 0
matriz_reducida <- as(matriz_reducida, "matrix")
matriz_reducida <- as(matriz_reducida, "dgCMatrix")
matriz_reducida@x[matriz_reducida@x >= 1] <- 1
# -------------------------------------------
# PREPARACIÓN DE DATOS PARA EL OBJETIVO 4
# -------------------------------------------
# 3. Extraer clientes que forman parte del objetivo 4
obj4 <- objetivos[[4]]$obj
# Limpiar nombres de columnas de la matriz para eliminar un carácter inicial no deseado
colnames(matriz_reducida) <- sub("^.", "", colnames(matriz_reducida))
# Filtrar la matriz solo para los clientes del objetivo 4
matriz_sparse_filt <- matriz_reducida[rownames(matriz_reducida) %in% obj4, ]
# Convertir matrices a formato sparse para optimizar cálculos
matriz_sparse_filt <- as(matriz_sparse_filt, "dgCMatrix")
matriz_reducida <- as(matriz_reducida, "dgCMatrix")
# 4. Filtrar tickets solo para clientes del objetivo 4 y convertir fechas a formato Date
tickets_filtrados <- tickets %>%
filter(id_cliente_enc %in% obj4) %>%
mutate(fecha = ymd(dia))
# 5. Obtener el último ticket de compra por cada cliente (más reciente)
ultimos_tickets <- tickets_filtrados %>%
group_by(id_cliente_enc) %>%
filter(fecha == max(fecha)) %>%
ungroup()
# -------------------------------------------
# VERIFICACIÓN DE CLIENTES Y ENTRENAMIENTO DEL MODELO
# -------------------------------------------
# 8. Verificar que los clientes objetivo estén presentes en la matriz de interacciones
clientes_en_matriz <- intersect(obj4, rownames(matriz_reducida))
length(clientes_en_matriz)
# 10. Inicializar y entrenar modelo WRMF para recomendaciones con parámetros dados
modelo_wrmf_o4 <- WRMF$new(rank = 10L,
lambda = 0.1,
feedback = 'implicit')
modelo_wrmf_o4$fit_transform(matriz_reducida,
n_iter = 1000L,
convergence_tol = 1e-6)
# -------------------------------------------
# EXCLUSIÓN DE PRODUCTOS YA COMPRADOS RECIENTEMENTE
# -------------------------------------------
# 11. Obtener lista de todos los productos en la matriz
productos_matriz <- colnames(matriz_reducida)
# 14. Crear matriz para marcar productos que no deben recomendarse (los ya comprados últimamente)
not_recommend_df <- matrix(0,
nrow = nrow(matriz_reducida),
ncol = ncol(matriz_reducida))
rownames(not_recommend_df) <- rownames(matriz_reducida)
colnames(not_recommend_df) <- productos_matriz
# 15. Para cada cliente, marcar con 1 los productos de su último ticket para excluirlos de recomendaciones
for (cliente in clientes_en_matriz) {
# Extraer productos comprados en el último ticket del cliente
productos_ultimo_ticket <- ultimos_tickets %>%
filter(id_cliente_enc == cliente) %>%
pull(cod_est)
# Mantener solo productos que están en la matriz de productos
productos_validos <- intersect(productos_ultimo_ticket, productos_matriz)
if (length(productos_validos) > 0) {
# Marcar con 1 en la matriz de exclusión
not_recommend_df[cliente, productos_validos] <- 1
cat("Cliente", cliente, "tiene", length(productos_validos), "productos marcados como no recomendables\n")
} else {
cat("Cliente", cliente, "no tiene productos para excluir\n")
}
}
# Convertir la matriz de exclusión a formato sparse
not_recommend_matrix <- as(not_recommend_df, "dgCMatrix")
# -------------------------------------------
# GENERACIÓN DE RECOMENDACIONES
# -------------------------------------------
# 16. Predecir recomendaciones para clientes objetivo,
# excluyendo productos comprados recientemente
preds_o4 <- modelo_wrmf_o4$predict(
not_recommend_matrix[clientes_en_matriz, ],
k = 1,
not_recommend = not_recommend_matrix[clientes_en_matriz, ]
)
# Extraer ids de productos recomendados (primer recomendación) y asignar nombres de clientes
predicciones <- as.data.frame(attr(preds_o4, "ids"))
predicciones$clientes <- rownames(predicciones)
rownames(predicciones) <- NULL
# Seleccionar columnas relevantes: cliente y producto recomendado
predicciones <- predicciones %>%
select(clientes, V1)
# Hacer join para obtener descripción de productos desde tabla maestro
predicciones <- predicciones %>%
left_join(maestro, by = c("V1" = "cod_est"))
# Renombrar columnas para mayor claridad
colnames(predicciones) <- c("CLIENTES", "COD_PRODUCTO", "DESCRIPCION")
predicciones
not_recommend_matrix
predicciones
not_recommend_matrix
library(tidyverse)
library(lubridate)
library(rsparse)
library(dplyr)
library(Matrix)
# 1. Cargar datos desde archivos RDS
maestro <- readRDS("maestroestr.RDS")
objetivos <- readRDS("objetivos.RDS")
tickets <- readRDS("tickets_enc.RDS")
matriz_reducida <- readRDS("MatrizSuperReducida.RDS")
# Como carga dataframe convertimos los NAs en 0 y cambio el formato
matriz_reducida[is.na(matriz_reducida)] <- 0
matriz_reducida <- as(matriz_reducida, "matrix")
matriz_reducida <- as(matriz_reducida, "dgCMatrix")
matriz_reducida@x[matriz_reducida@x >= 1] <- 1
# -------------------------------------------
# PREPARACIÓN DE DATOS PARA EL OBJETIVO 4
# -------------------------------------------
# 3. Extraer clientes que forman parte del objetivo 4
obj4 <- objetivos[[4]]$obj
# Limpiar nombres de columnas de la matriz para eliminar un carácter inicial no deseado
colnames(matriz_reducida) <- sub("^.", "", colnames(matriz_reducida))
# Filtrar la matriz solo para los clientes del objetivo 4
matriz_sparse_filt <- matriz_reducida[rownames(matriz_reducida) %in% obj4, ]
# Convertir matrices a formato sparse para optimizar cálculos
matriz_sparse_filt <- as(matriz_sparse_filt, "dgCMatrix")
matriz_reducida <- as(matriz_reducida, "dgCMatrix")
# 4. Filtrar tickets solo para clientes del objetivo 4 y convertir fechas a formato Date
tickets_filtrados <- tickets %>%
filter(id_cliente_enc %in% obj4) %>%
mutate(fecha = ymd(dia))
# 5. Obtener el último ticket de compra por cada cliente (más reciente)
ultimos_tickets <- tickets_filtrados %>%
group_by(id_cliente_enc) %>%
filter(fecha == max(fecha)) %>%
ungroup()
# -------------------------------------------
# VERIFICACIÓN DE CLIENTES Y ENTRENAMIENTO DEL MODELO
# -------------------------------------------
# 8. Verificar que los clientes objetivo estén presentes en la matriz de interacciones
clientes_en_matriz <- intersect(obj4, rownames(matriz_reducida))
length(clientes_en_matriz)
# 10. Inicializar y entrenar modelo WRMF para recomendaciones con parámetros dados
modelo_wrmf_o4 <- WRMF$new(rank = 10L,
lambda = 0.1,
feedback = 'implicit')
modelo_wrmf_o4$fit_transform(matriz_reducida,
n_iter = 1000L,
convergence_tol = 1e-6)
# -------------------------------------------
# EXCLUSIÓN DE PRODUCTOS YA COMPRADOS RECIENTEMENTE
# -------------------------------------------
# 11. Obtener lista de todos los productos en la matriz
productos_matriz <- colnames(matriz_reducida)
# 14. Crear matriz para marcar productos que no deben recomendarse (los ya comprados últimamente)
not_recommend_df <- matrix(0,
nrow = nrow(matriz_reducida),
ncol = ncol(matriz_reducida))
rownames(not_recommend_df) <- rownames(matriz_reducida)
colnames(not_recommend_df) <- productos_matriz
# 15. Para cada cliente, marcar con 1 los productos de su último ticket para excluirlos de recomendaciones
for (cliente in clientes_en_matriz) {
# Extraer productos comprados en el último ticket del cliente
productos_ultimo_ticket <- ultimos_tickets %>%
filter(id_cliente_enc == cliente) %>%
pull(cod_est)
# Mantener solo productos que están en la matriz de productos
productos_validos <- intersect(productos_ultimo_ticket, productos_matriz)
if (length(productos_validos) > 0) {
# Marcar con 1 en la matriz de exclusión
not_recommend_df[cliente, productos_validos] <- 1
cat("Cliente", cliente, "tiene", length(productos_validos), "productos marcados como no recomendables\n")
} else {
cat("Cliente", cliente, "no tiene productos para excluir\n")
}
}
# Convertir la matriz de exclusión a formato sparse
not_recommend_matrix <- as(not_recommend_df, "dgCMatrix")
# -------------------------------------------
# GENERACIÓN DE RECOMENDACIONES
# -------------------------------------------
# 16. Predecir recomendaciones para clientes objetivo,
# excluyendo productos comprados recientemente
preds_o4 <- modelo_wrmf_o4$predict(
not_recommend_matrix,
k = 1,
not_recommend = not_recommend_matrix
)
# -------------------------------------------
# PROCESAMIENTO DE RESULTADOS
# -------------------------------------------
# Extraer ids de productos recomendados (primer recomendación) y asignar nombres de clientes
predicciones <- as.data.frame(attr(preds_o4, "ids"))
predicciones$clientes <- rownames(predicciones)
rownames(predicciones) <- NULL
# Seleccionar columnas relevantes: cliente y producto recomendado
predicciones <- predicciones %>%
select(clientes, V1)
# Hacer join para obtener descripción de productos desde tabla maestro
predicciones <- predicciones %>%
left_join(maestro, by = c("V1" = "cod_est"))
# Renombrar columnas para mayor claridad
colnames(predicciones) <- c("CLIENTES", "COD_PRODUCTO", "DESCRIPCION")
predicciones
clientes_en_matriz
not_recommend_matrix
=======
# =======================
# 1. Librerías necesarias
# =======================
library(dplyr)
library(ggplot2)
library(tidyr)
library(GGally)
library(lubridate)
library(readr)
# ===============
# 2. Cargar datos
# ===============
# Datos originales necesarios para reconstruir las variables
tickets_enc <- readRDS("tickets_enc.RDS")
clientes_clusterizados <- readRDS("clientes_clusterizados.RDS")
matriz_base <- readRDS("matriz.RDS")
# ==============================
# 3. Preprocesamiento de tickets
# ==============================
tickets_enc <- tickets_enc %>%
mutate(
num_ticket = as.character(num_ticket),
dia = ymd(dia),
num_ticket = paste(num_ticket, id_cliente_enc),
DiaSemana = wday(dia, week_start = 1)
)
# ============================================
# 4. Ingeniería de características por cliente
# ============================================
# Agregar las variables de comportamiento por cliente
datos_clientes <- tickets_enc %>%
group_by(id_cliente_enc) %>%
summarise(
total_productos        = n(),
productos_distintos    = n_distinct(cod_est),
dias_activos           = as.numeric(max(dia) - min(dia)),
compras_por_semana     = ifelse(dias_activos > 0, n() / (dias_activos / 7), n()),
compras_entre_semana   = sum(DiaSemana %in% 1:5),
compras_fin_de_semana  = sum(DiaSemana %in% 6:7)
) %>%
ungroup()
# ==============================================
# 5. Reconstruir matriz con clusters + variables
# ==============================================
matriz_df <- matriz_base %>%
as.data.frame() %>%
mutate(id_cliente_enc = rownames(.))
# Unir los clusters y las variables de comportamiento por cliente
matriz_con_cluster <- matriz_df %>%
inner_join(clientes_clusterizados, by = "id_cliente_enc") %>%
left_join(datos_clientes, by = "id_cliente_enc")
# Verifica que las variables de comportamiento estén presentes
names(matriz_con_cluster)
# ===================================
# 6. Análisis descriptivo por cluster
# ===================================
summary_tabla <- matriz_con_cluster %>%
group_by(kmeans_cluster) %>%
summarise(
n_clientes              = n(),
total_productos_medio   = mean(total_productos, na.rm = TRUE),
productos_distintos     = mean(productos_distintos, na.rm = TRUE),
dias_activos_promedio   = mean(dias_activos, na.rm = TRUE),
compras_por_semana      = mean(compras_por_semana, na.rm = TRUE),
compras_entre_semana    = mean(compras_entre_semana, na.rm = TRUE),
compras_fin_de_semana   = mean(compras_fin_de_semana, na.rm = TRUE),
prop_fin_semana         = mean(compras_fin_de_semana / (compras_entre_semana + compras_fin_de_semana), na.rm = TRUE)
)
print(summary_tabla)
# ========================
# 7. Boxplots por variable
# ========================
variables <- c("total_productos", "productos_distintos", "dias_activos",
"compras_por_semana", "compras_entre_semana", "compras_fin_de_semana")
for (var in variables) {
p <- ggplot(matriz_con_cluster, aes_string(x = "kmeans_cluster", y = var, fill = "kmeans_cluster")) +
geom_boxplot(alpha = 0.7) +
labs(
title = paste("Distribución de", var, "por Cluster"),
x = "Cluster",
y = var
) +
theme_minimal() +
theme(legend.position = "none")
print(p)
}
# ==================================================
# 8. Perfiles promedio por cluster (gráfico resumen)
# ==================================================
promedios_long <- matriz_con_cluster %>%
group_by(kmeans_cluster) %>%
summarise(across(all_of(variables), ~mean(.x, na.rm = TRUE))) %>%
pivot_longer(-kmeans_cluster, names_to = "variable", values_to = "valor")
ggplot(promedios_long, aes(x = variable, y = valor, fill = kmeans_cluster)) +
geom_col(position = "dodge") +
coord_flip() +
labs(
title = "Promedio de Variables por Cluster",
x = "Variable",
y = "Valor Promedio"
) +
theme_minimal()
# ==================================================
# 8. Perfiles promedio por cluster (gráfico resumen)
# ==================================================
promedios_long <- matriz_con_cluster %>%
group_by(kmeans_cluster) %>%
summarise(across(all_of(variables), ~mean(.x, na.rm = TRUE))) %>%
pivot_longer(-kmeans_cluster, names_to = "variable", values_to = "valor")
ggplot(promedios_long, aes(x = variable, y = valor, fill = kmeans_cluster)) +
geom_col(position = "dodge") +
coord_flip() +
labs(
title = "Promedio de Variables por Cluster",
x = "Variable",
y = "Valor Promedio"
) +
theme_minimal()
# =======================================
# 9. Correlaciones dentro de cada cluster
# =======================================
for (i in unique(matriz_con_cluster$kmeans_cluster)) {
datos_cluster <- matriz_con_cluster %>%
filter(kmeans_cluster == i) %>%
select(all_of(variables)) %>%
drop_na()
print(paste("Correlaciones - Cluster", i))
print(ggpairs(datos_cluster, title = paste("Correlaciones en Cluster", i)))
}
>>>>>>> 9f8eafb1b41b6d11bee8ce1ab201f396e8f9e035
