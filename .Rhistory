
maestrostr <- readRDS("Datos/originales/maestroestr.RDS")
objetivos <- readRDS("Datos/originales/objetivos.RDS")
tickets_enc <- readRDS("Datos/originales/tickets_enc.RDS")
matriz=readRDS("Datos/transformados/matriz.RDS")
# Cargar librerías necesarias
library(recommenderlab)
maestrostr <- readRDS("Datos/originales/maestroestr.RDS")
objetivos <- readRDS("Datos/originales/objetivos.RDS")
maestrostr <- readRDS("Datos/originales/maestroestr.RDS")
maestrostr <- readRDS("Datos/originales/maestroestr.RDS")
df=read.csv("C:/Users/jonba/Downloads/spotify_cl.csv")
View(df)
df$cluster=as.factor(df$cluster)
ui=fluidPage(
titlePanel("Spotify TOP 2018"),
sidebarLayout(
sidebarPanel(
sliderInput('ranking', label='Number of observations:', min=1, max=100, value= c(1,100)),
selectInput('variable', 'seleciona la variable', choices = c('acousticness', 'danceability')),
selelectInput("cluster", "Selecciona cluster:", choices = 1:5),  # assuming 5 clusters
actionButton("goButton", "Ejecutar")
),
mainPanel(
tabsetPanel(
tabPanel("Canciones", dataTableOutput("songs_table")),
tabPanel("Cluster", plotOutput("cluster_plot")),
tabPanel("Variable", plotOutput("var_plot"))
)
)
)
)
install.packages("shiny")
ui=fluidPage(
titlePanel("Spotify TOP 2018"),
sidebarLayout(
sidebarPanel(
sliderInput('ranking', label='Number of observations:', min=1, max=100, value= c(1,100)),
selectInput('variable', 'seleciona la variable', choices = c('acousticness', 'danceability')),
selelectInput("cluster", "Selecciona cluster:", choices = 1:5),  # assuming 5 clusters
actionButton("goButton", "Ejecutar")
),
mainPanel(
tabsetPanel(
tabPanel("Canciones", dataTableOutput("songs_table")),
tabPanel("Cluster", plotOutput("cluster_plot")),
tabPanel("Variable", plotOutput("var_plot"))
)
)
)
)
library(shiny)
df$cluster=as.factor(df$cluster)
ui=fluidPage(
titlePanel("Spotify TOP 2018"),
sidebarLayout(
sidebarPanel(
sliderInput('ranking', label='Number of observations:', min=1, max=100, value= c(1,100)),
selectInput('variable', 'seleciona la variable', choices = c('acousticness', 'danceability')),
selelectInput("cluster", "Selecciona cluster:", choices = 1:5),  # assuming 5 clusters
actionButton("goButton", "Ejecutar")
),
mainPanel(
tabsetPanel(
tabPanel("Canciones", dataTableOutput("songs_table")),
tabPanel("Cluster", plotOutput("cluster_plot")),
tabPanel("Variable", plotOutput("var_plot"))
)
)
)
)
ui=fluidPage(
titlePanel("Spotify TOP 2018"),
sidebarLayout(
sidebarPanel(
sliderInput('ranking', label='Number of observations:', min=1, max=100, value= c(1,100)),
selectInput('variable', 'seleciona la variable', choices = c('acousticness', 'danceability')),
selectInput("cluster", "Selecciona cluster:", choices = 1:5),  # assuming 5 clusters
actionButton("goButton", "Ejecutar")
),
mainPanel(
tabsetPanel(
tabPanel("Canciones", dataTableOutput("songs_table")),
tabPanel("Cluster", plotOutput("cluster_plot")),
tabPanel("Variable", plotOutput("var_plot"))
)
)
)
)
ui=fluidPage(
titlePanel("Spotify TOP 2018"),
sidebarLayout(
sidebarPanel(
sliderInput('ranking', label='Number of observations:', min=1, max=100, value= c(1,100)),
selectInput('variable', 'seleciona la variable', choices = c('acousticness', 'danceability')),
selectInput("cluster", "Selecciona cluster:", choices = 1:5),  # assuming 5 clusters
actionButton("goButton", "Ejecutar")
),
mainPanel(
tabsetPanel(
tabPanel("Canciones", dataTableOutput("songs_table")),
tabPanel("Cluster", plotOutput("cluster_plot")),
tabPanel("Variable", plotOutput("var_plot"))
)
)
)
)
library(DT)
ui = fluidPage(
titlePanel("Spotify TOP 2018"),
sidebarLayout(
sidebarPanel(
sliderInput('ranking', label = 'Posición en el ranking:', min = 1, max = 100, value = c(1, 100)),
selectInput('variable', 'Selecciona la variable', choices = c('acousticness', 'danceability')),
selectInput("cluster", "Selecciona cluster:", choices = 1:5),
actionButton("goButton", "Ejecutar")
),
mainPanel(
tabsetPanel(
tabPanel("Canciones", DT::DTOutput("songs_table")),
tabPanel("Cluster", plotOutput("cluster_plot")),
tabPanel("Variable", plotOutput("var_plot"))
)
)
)
)
ui
View(ui)
plot(ui)
ui = fluidPage(
titlePanel("Spotify TOP 2018"),
sidebarLayout(
sidebarPanel(
sliderInput('ranking', label = 'Posición en el ranking:', min = 1, max = 100, value = c(1, 100)),
selectInput('variable', 'Selecciona la variable', choices = c('acousticness', 'danceability')),
selectInput("cluster", "Selecciona cluster:", choices = 1:5),
actionButton("goButton", "Ejecutar")
),
mainPanel(
tabsetPanel(
tabPanel("Canciones", DT::DTOutput("songs_table")),
tabPanel("Cluster", plotOutput("cluster_plot")),
tabPanel("Variable", plotOutput("var_plot"))
)
)
)
)
ui
ui = fluidPage(
titlePanel("Spotify TOP 2018"),
sidebarLayout(
sidebarPanel(
sliderInput('ranking', label = 'Posición en el ranking:', min = 1, max = 100, value = c(1, 100)),
selectInput('variable', 'Selecciona la variable', choices = c('acousticness', 'danceability')),
selectInput("cluster", "Selecciona cluster:", choices = 1:5),
actionButton("goButton", "Ejecutar")
),
mainPanel(
tabsetPanel(
tabPanel("Canciones", DT::DTOutput("songs_table")),
tabPanel("Cluster", plotOutput("cluster_plot")),
tabPanel("Variable", plotOutput("var_plot"))
)
)
)
)
shinyApp(ui=ui, server=server)
shinyApp(ui=ui, server = server)
maestrostr <- readRDS("Datos/maestroestr.RDS")
objetivos <- readRDS("Datos/objetivos.RDS")
tickets_enc <- readRDS("Datos/tickets_enc.RDS")
matriz=readRDS("Datos/matriz.RDS")
# Cargar librerías necesarias
library(tidyverse)
maestrostr <- readRDS("Datos/maestroestr.RDS")
objetivos <- readRDS("Datos/objetivos.RDS")
maestrostr <- readRDS("Datos/maestroestr.RDS")

datos <- readRSD("Datos//Transformados//matriz.RDS")
datos <- readRDS("Datos//Transformados//matriz.RDS")
datos <- readRDS("matriz.RDS")
library(plumber)
library(recommenderlab)
matriz <- readRDS("C:/Users/Personal/Desktop/BDATA 1/Reto 4/RETO 4 GITHUB/RETO_04_NARANJA/matriz.RDS")
View(datos)
View(matriz)
# Leer la matriz desde el archivo RDS
purchase_matrix <- readRDS("matriz.RDS")
# Validar que es una matriz
stopifnot(is.matrix(purchase_matrix))
# Cargar la matriz desde el archivo
purchase_matrix <- readRDS("matriz.RDS")
# Convertir a matriz si no lo es
if (!is.matrix(purchase_matrix)) {
purchase_matrix <- as.matrix(purchase_matrix)
}
# Crear realRatingMatrix para recommenderlab
rating_rrm <- as(purchase_matrix, "realRatingMatrix")
# Entrenar modelo colaborativo basado en usuarios
rec_model <- Recommender(rating_rrm, method = "UBCF")
#* Obtener recomendaciones para un usuario
#* @param user_id ID del usuario (por ejemplo, "user1")
#* @param n Número de recomendaciones (por defecto 3)
#* @get /recommend
function(user_id = "user1", n = 3) {
if (!(user_id %in% rownames(purchase_matrix))) {
return(list(error = "Usuario no encontrado"))
}
pred <- predict(rec_model, rating_rrm[user_id], n = as.numeric(n))
recs <- as(pred, "list")[[1]]
return(list(
usuario = user_id,
recomendaciones = recs
))
}
# Cargar y lanzar la API
r <- plumb("api.R")
r$run(host = "0.0.0.0", port = 8000)
# Cargar librerías
library(plumber)
library(recommenderlab)
# Leer la matriz desde RDS
purchase_matrix <- readRDS("matriz.RDS")
# Convertir a matriz si es data.frame u otra estructura
if (!is.matrix(purchase_matrix)) {
purchase_matrix <- as.matrix(purchase_matrix)
}
# Verificar que tiene nombres de fila (usuarios)
if (is.null(rownames(purchase_matrix))) {
stop("La matriz debe tener nombres de fila (user_id)")
}
# Convertir a realRatingMatrix
rating_rrm <- as(purchase_matrix, "realRatingMatrix")
# Entrenar modelo colaborativo basado en usuarios (UBCF)
rec_model <- Recommender(rating_rrm, method = "UBCF")
#* Recomendaciones para un usuario
#* @param user_id ID del usuario (debe coincidir con las filas de la matriz)
#* @param n Número de recomendaciones (por defecto 3)
#* @get /recommend
function(user_id = "user1", n = 3) {
# Validar existencia del usuario
if (!(user_id %in% rownames(purchase_matrix))) {
return(list(error = paste("Usuario", user_id, "no encontrado")))
}
# Hacer predicción
pred <- predict(rec_model, rating_rrm[user_id], n = as.numeric(n))
recs <- as(pred, "list")[[1]]
# Retornar recomendaciones
return(list(
usuario = user_id,
recomendaciones = recs
))
}
# Cargar y ejecutar API
r <- plumb("api.R")
#############################################
library(plumber)
r$run(host = "0.0.0.0", port = 8000)
#Cargar librerías necesarias
library(plumber)
library(tidyverse)
library(factoextra)
options(scipen = 999)
#Cargar datos 2022
pymes_2022 <- read.csv("Datos//Transformados//PYMES_IMPUTADO2022.csv")
ratios2022 <- pymes_2022 %>% select(ROA, ROE, EBITDA, Liquidez, Fondo_maniobra,
Endeudamiento, Endeudamiento_CP, Endeudamiento_LP,
Independencia, Tangibilidad, Intangibilidad)
ratios2022 <- ratios2022[apply(ratios2022, 1, function(x) all(is.finite(x))), ] #elimina NA, NaN e inf
# Cargar librerías
library(plumber)
library(recommenderlab)
# Leer la matriz desde RDS
purchase_matrix <- readRDS("matriz.RDS")
# Convertir a matriz si es data.frame u otra estructura
if (!is.matrix(purchase_matrix)) {
purchase_matrix <- as.matrix(purchase_matrix)
}
# Verificar que tiene nombres de fila (usuarios)
if (is.null(rownames(purchase_matrix))) {
stop("La matriz debe tener nombres de fila (user_id)")
}
# Convertir a realRatingMatrix
rating_rrm <- as(purchase_matrix, "realRatingMatrix")
# Entrenar modelo colaborativo basado en usuarios (UBCF)
rec_model <- Recommender(rating_rrm, method = "UBCF")
#* Recomendaciones para un usuario
#* @param user_id ID del usuario (debe coincidir con las filas de la matriz)
#* @param n Número de recomendaciones (por defecto 3)
#* @get /recommend
function(user_id = "user1", n = 3) {
# Validar existencia del usuario
if (!(user_id %in% rownames(purchase_matrix))) {
return(list(error = paste("Usuario", user_id, "no encontrado")))
}
# Hacer predicción
pred <- predict(rec_model, rating_rrm[user_id], n = as.numeric(n))
recs <- as(pred, "list")[[1]]
# Retornar recomendaciones
return(list(
usuario = user_id,
recomendaciones = recs
))
}
#############################################
library(plumber)
# Cargar y ejecutar API
r <- plumb("api.R")
r$run(host = "0.0.0.0", port = 8000)
source("run_api.R")
library(plumber)
library(recommenderlab)
# Cargar la matriz desde el archivo
purchase_matrix <- readRDS("matriz.RDS")
# Convertir a matriz si no lo es
if (!is.matrix(purchase_matrix)) {
purchase_matrix <- as.matrix(purchase_matrix)
}
# Crear realRatingMatrix para recommenderlab
rating_rrm <- as(purchase_matrix, "realRatingMatrix")
# Entrenar modelo colaborativo basado en usuarios
rec_model <- Recommender(rating_rrm, method = "UBCF")
#* Obtener recomendaciones para un usuario
#* @param user_id ID del usuario (por ejemplo, "user1")
#* @param n Número de recomendaciones (por defecto 3)
#* @get /recommend
function(user_id = "user1", n = 3) {
if (!(user_id %in% rownames(purchase_matrix))) {
return(list(error = "Usuario no encontrado"))
}
pred <- predict(rec_model, rating_rrm[user_id], n = as.numeric(n))
recs <- as(pred, "list")[[1]]
return(list(
usuario = user_id,
recomendaciones = recs
))
}
library(plumber)
library(recommenderlab)
# Cargar la matriz desde el archivo
purchase_matrix <- readRDS("matriz.RDS")
# Convertir a matriz si no lo es
if (!is.matrix(purchase_matrix)) {
purchase_matrix <- as.matrix(purchase_matrix)
}
# Crear realRatingMatrix para recommenderlab
rating_rrm <- as(purchase_matrix, "realRatingMatrix")
# Entrenar modelo colaborativo basado en usuarios
rec_model <- Recommender(rating_rrm, method = "UBCF")
#* Obtener recomendaciones para un usuario
#* @param user_id ID del usuario (por ejemplo, "user1")
#* @param n Número de recomendaciones (por defecto 3)
#* @get /recommend
recommend_function <- function(user_id = "user1", n = 3) {
if (!(user_id %in% rownames(purchase_matrix))) {
return(list(error = "Usuario no encontrado"))
}
pred <- predict(rec_model, rating_rrm[user_id], n = as.numeric(n))
recs <- as(pred, "list")[[1]]
return(list(
usuario = user_id,
recomendaciones = recs
))
}
# Crear y lanzar el API
pr <- plumber::plumb()
pr$handle("GET", "/recommend", recommend_function)
pr$run(host = "0.0.0.0", port = 8000)
library(plumber)
library(recommenderlab)
# Cargar la matriz desde el archivo
purchase_matrix <- readRDS("matriz.RDS")
# Convertir a matriz si no lo es
if (!is.matrix(purchase_matrix)) {
purchase_matrix <- as.matrix(purchase_matrix)
}
# Crear realRatingMatrix para recommenderlab
rating_rrm <- as(purchase_matrix, "realRatingMatrix")
# Entrenar modelo colaborativo basado en usuarios
rec_model <- Recommender(rating_rrm, method = "UBCF")
# Definir función del endpoint
recommend_function <- function(user_id = "user1", n = 3) {
if (!(user_id %in% rownames(purchase_matrix))) {
return(list(error = "Usuario no encontrado"))
}
pred <- predict(rec_model, rating_rrm[user_id], n = as.numeric(n))
recs <- as(pred, "list")[[1]]
return(list(
usuario = user_id,
recomendaciones = recs
))
}
# Crear router manualmente
api <- pr() |>
pr_get("/recommend", recommend_function) |>
pr_set_api_spec(list(info = list(title = "API de Recomendaciones Personalizadas")))
# Ejecutar el API
api$run(host = "0.0.0.0", port = 8000)
library(plumber)
library(recommenderlab)
# Cargar la matriz desde el archivo
purchase_matrix <- readRDS("matriz.RDS")
# Convertir a matriz si no lo es
if (!is.matrix(purchase_matrix)) {
purchase_matrix <- as.matrix(purchase_matrix)
}
# Crear realRatingMatrix para recommenderlab
rating_rrm <- as(purchase_matrix, "realRatingMatrix")
# Entrenar modelo colaborativo basado en usuarios
rec_model <- Recommender(rating_rrm, method = "UBCF")
# Definir función del endpoint
recommend_function <- function(user_id = "user1", n = 3) {
if (!(user_id %in% rownames(purchase_matrix))) {
return(list(error = "Usuario no encontrado"))
}
pred <- predict(rec_model, rating_rrm[user_id], n = as.numeric(n))
recs <- as(pred, "list")[[1]]
return(list(
usuario = user_id,
recomendaciones = recs
))
}
# Crear el router
api <- pr() |>
pr_get("/recommend", recommend_function) |>
pr_set_api_spec(list(
openapi = "3.0.0",
info = list(
title = "API de Recomendaciones Personalizadas",
version = "1.0.0"
)
))
# Ejecutar el API
api$run(host = "0.0.0.0", port = 8000)
library(plumber)
library(recommenderlab)
# Cargar la matriz desde el archivo
purchase_matrix <- readRDS("matriz.RDS")
# Convertir a matriz si no lo es
if (!is.matrix(purchase_matrix)) {
purchase_matrix <- as.matrix(purchase_matrix)
}
# Crear realRatingMatrix para recommenderlab
rating_rrm <- as(purchase_matrix, "realRatingMatrix")
# Entrenar modelo colaborativo basado en usuarios
rec_model <- Recommender(rating_rrm, method = "UBCF")
# Definir función del endpoint
#* @get /recommend
#* @param user_id ID del usuario (por ejemplo, "user1")
#* @param n Número de recomendaciones (por defecto 3)
#* @response 200 Recomendaciones para el usuario
recommend_function <- function(user_id = "user1", n = 3) {
if (!(user_id %in% rownames(purchase_matrix))) {
return(list(error = "Usuario no encontrado"))
}
pred <- predict(rec_model, rating_rrm[user_id], n = as.numeric(n))
recs <- as(pred, "list")[[1]]
return(list(
usuario = user_id,
recomendaciones = recs
))
}
# Crear y ejecutar el API
api <- pr()
# Asociar la función al endpoint /recommend
api$handle("GET", "/recommend", recommend_function)
# Definir la especificación OpenAPI para la documentación
api$set_api_spec(list(
openapi = "3.0.0",
info = list(
title = "API de Recomendaciones Personalizadas",
version = "1.0.0",
description = "API para generar recomendaciones basadas en un modelo colaborativo de usuarios."
)
))
# Ejecutar el API
api$run(host = "0.0.0.0", port = 8000)
library(plumber)
library(recommenderlab)
# Cargar la matriz desde el archivo
purchase_matrix <- readRDS("matriz.RDS")
# Convertir a matriz si no lo es
if (!is.matrix(purchase_matrix)) {
purchase_matrix <- as.matrix(purchase_matrix)
}
# Crear realRatingMatrix para recommenderlab
rating_rrm <- as(purchase_matrix, "realRatingMatrix")
# Entrenar modelo colaborativo basado en usuarios
rec_model <- Recommender(rating_rrm, method = "UBCF")
# Definir función del endpoint
#* @get /recommend
#* @param user_id ID del usuario (por ejemplo, "user1")
#* @param n Número de recomendaciones (por defecto 3)
#* @response 200 OK Recomendaciones para el usuario
#* @response 500 Internal Server Error Si el usuario no es encontrado
#* @examples response(200, list(usuario = "user1", recomendaciones = c("item1", "item2", "item3")))
#* @examples response(500, "Usuario no encontrado")
recommend_function <- function(user_id = "user1", n = 3) {
if (!(user_id %in% rownames(purchase_matrix))) {
return(list(error = "Usuario no encontrado"))
}
pred <- predict(rec_model, rating_rrm[user_id], n = as.numeric(n))
recs <- as(pred, "list")[[1]]
return(list(
usuario = user_id,
recomendaciones = recs
))
}
# Crear el API
api <- pr()
# Asociar la función al endpoint /recommend
api$handle("GET", "/recommend", recommend_function)
# Definir la especificación OpenAPI para la documentación
api$set_api_spec(list(
openapi = "3.0.0",
info = list(
title = "API de Recomendaciones Personalizadas",
version = "1.0.0",
description = "API para generar recomendaciones basadas en un modelo colaborativo de usuarios."
),
paths = list(
"/recommend" = list(
get = list(
summary = "Obtener recomendaciones personalizadas",
description = "Devuelve una lista de recomendaciones para un usuario",
parameters = list(
list(
name = "user_id",
in = "query",
# Ejecutar el API
api$run(host = "0.0.0.0", port = 8000)

