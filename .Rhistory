resultado$producto_recomendado<- sub("^X", "", resultado$producto_recomendado)
resultado_final<- merge(resultado,
productos,
by.x = "producto_recomendado",
by.y = "cod_est",
all.x = TRUE)
resultado_final<- resultado_final[, c("cliente", "producto_recomendado", "descripcion")]
resultado_final
scores_matrix<- modelo_ALS$predict(matriz_sparse[id_usuarios, , drop = FALSE], k = ncol(matriz_sparse))
resultados_con_score <- data.frame(cliente = clientes_objetivo,
producto_recomendado = character(length(clientes_objetivo)),
score = numeric(length(clientes_objetivo)),
stringsAsFactors = FALSE)
for (i in seq_along(id_usuarios)) {
user_idx <- id_usuarios[i]
user_scores <- scores_matrix[i, ]
user_compras <- matriz_sparse[user_idx, ]
user_scores[user_compras > 0]<- -Inf
best_product_idx <- which.max(user_scores)
resultados_con_score$producto_recomendado[i] <- colnames(matriz_sparse)[best_product_idx]
resultados_con_score$score[i] <- user_scores[best_product_idx]
}
resultados_con_score$producto_recomendado <- sub("^X", "", resultados_con_score$producto_recomendado)
resultado_final <- merge(resultados_con_score,
productos,
by.x = "producto_recomendado",
by.y = "cod_est",
all.x = TRUE)
resultado_final <- resultado_final[, c("cliente", "producto_recomendado", "descripcion", "score")]
str(scores_matrix)
scores_matrix<- modelo_ALS$predict(matriz_sparse[id_usuarios, , drop = FALSE], type = "score")
scores_matrix<- modelo_ALS$predict(matriz_sparse[id_usuarios, , drop = FALSE], type = "score")
scores_matrix <- modelo_ALS$predict(matriz_sparse[id_usuarios, , drop = FALSE], type = "score")
modelo_ALS$fit_transform(matriz_sparse)
U <- modelo_ALS$user_factors
P <- modelo_ALS$item_factorsU <- modelo_ALS$user_factors
U <- modelo_ALS$user_factors
P <- modelo_ALS$item_factors
U_obj <- U[id_usuarios, ]  # matriz de embeddings para los clientes objetivo
scores_matrix <- U_obj %*% t(P)  # matriz de scores: (10 x num_productos)
P
LS$fit_transform(matriz_sparse)
LS$fit_transform(matriz_sparse)
modelo_ALS$fit_transform(matriz_sparse)
U <- modelo_ALS$user_factors
P <- modelo_ALS$item_factors
U_obj <- U[id_usuarios, ]  # matriz de embeddings para los clientes objetivo
scores_matrix <- U_obj %*% t(P)  # matriz de scores: (10 x num_productos)
#===============================
# 1. Librerías necesarias
# ===============================
library(lubridate)
library(dplyr)
library(naniar)
library(tidyr)
library(ggplot2)
library(cluster)
library(recosystem)
library(purrr)
#===============================
# 1. Librerías necesarias
# ===============================
library(lubridate)
library(dplyr)
library(naniar)
library(tidyr)
library(ggplot2)
library(cluster)
library(recosystem)
library(purrr)
# ===============================
# 2. Carga y preprocesamiento de datos
# ===============================
maestrostr <- readRDS("maestroestr.RDS")
objetivos  <- readRDS("objetivos.RDS")
tickets_enc <- readRDS("tickets_enc.RDS")
# Formateo inicial
tickets_enc <- tickets_enc %>%
mutate(
num_ticket = as.character(num_ticket),
dia        = ymd(dia),
num_ticket = paste(num_ticket, id_cliente_enc)
)
# Verificar NAs
vis_miss(tickets_enc, warn_large_data = FALSE)
# Agregar día de la semana
tickets_enc <- tickets_enc %>%
mutate(DiaSemana = wday(dia, week_start = 1))
# ===============================
# 3. Ingeniería de características para clustering
# ===============================
datos_clientes <- tickets_enc %>%
group_by(id_cliente_enc) %>%
summarise(
total_productos       = n(),
productos_distintos    = n_distinct(cod_est),
dias_activos          = as.numeric(max(dia) - min(dia)),
compras_por_semana    = ifelse(dias_activos > 0, n() / (dias_activos / 7), n()),
compras_entre_semana  = sum(DiaSemana %in% 1:5),
compras_fin_de_semana = sum(DiaSemana %in% 6:7)
) %>%
ungroup()
# Eliminar outliers con IQR
outliers_iqr <- function(x) {
q1 <- quantile(x, 0.25, na.rm = TRUE)
q3 <- quantile(x, 0.75, na.rm = TRUE)
iqr <- q3 - q1
which(x < (q1 - 1.5 * iqr) | x > (q3 + 1.5 * iqr))
}
idx_out <- unique(unlist(lapply(datos_clientes[-1], outliers_iqr)))
datos_sin_outliers <- datos_clientes[-idx_out, ]
# Escalado
datos_scaled <- datos_sin_outliers %>% select(-id_cliente_enc) %>% scale()
# ===============================
# 4. Método del codo para K-means
# ===============================
set.seed(123)
wss <- map_dbl(1:15, ~ kmeans(datos_scaled, centers = .x, nstart = 25)$tot.withinss)
elbow_df <- tibble(k = 1:15, wss = wss)
# Graficar método del codo
ggplot(elbow_df, aes(x = k, y = wss)) +
geom_line() +
geom_point() +
labs(
title = "Método del Codo: WSS vs Número de Clusters",
x = "Número de Clusters (k)",
y = "Suma de Cuadrados Intra-cluster (WSS)"
) +
theme_minimal()
# ===============================
# 5. K-means clustering (k = 3)
# ===============================
set.seed(123)
kmeans_result <- kmeans(datos_scaled, centers = 3, nstart = 25)
datos_sin_outliers$kmeans_cluster <- as.factor(kmeans_result$cluster)
# Visualización con PCA
pca_res <- prcomp(datos_scaled)
datos_sin_outliers <- datos_sin_outliers %>%
mutate(
pca1 = pca_res$x[,1],
pca2 = pca_res$x[,2]
)
ggplot(datos_sin_outliers, aes(x = pca1, y = pca2, color = kmeans_cluster)) +
geom_point(alpha = 0.7) +
labs(
title = "Clusters K-means en 2 Componentes Principales",
x = "PCA1",
y = "PCA2",
color = "Cluster"
) +
theme_minimal()
# ===============================
# 6. Guardar asignación de clusters
# ===============================
clientes_clusterizados <- datos_sin_outliers %>% select(id_cliente_enc, kmeans_cluster)
saveRDS(clientes_clusterizados, "clientes_clusterizados.RDS")
# ===============================
# 7. Crear matriz unificada con clusters
# ===============================
matriz_base <- readRDS("matriz.RDS")
matriz_df   <- matriz_base %>%
as.data.frame() %>%
mutate(id_cliente_enc = rownames(.))
matriz_con_cluster <- matriz_df %>%
inner_join(clientes_clusterizados, by = "id_cliente_enc") %>%
select(id_cliente_enc, kmeans_cluster, everything())
saveRDS(matriz_con_cluster, "matriz_con_cluster.RDS")
# ===============================
# 1. Librerías necesarias
# ===============================
library(dplyr)
library(ggplot2)
library(tidyr)
library(GGally)
library(lubridate)
library(readr)
# ===============================
# 1. Librerías necesarias
# ===============================
library(dplyr)
library(ggplot2)
library(tidyr)
library(GGally)
library(lubridate)
library(readr)
# ===============================
# 2. Cargar datos
# ===============================
# Datos originales necesarios para reconstruir las variables
tickets_enc <- readRDS("tickets_enc.RDS")
clientes_clusterizados <- readRDS("clientes_clusterizados.RDS")
matriz_base <- readRDS("matriz.RDS")
# ===============================
# 3. Preprocesamiento de tickets
# ===============================
tickets_enc <- tickets_enc %>%
mutate(
num_ticket = as.character(num_ticket),
dia = ymd(dia),
num_ticket = paste(num_ticket, id_cliente_enc),
DiaSemana = wday(dia, week_start = 1)
)
# ===============================
# 4. Ingeniería de características por cliente
# ===============================
# Agregar las variables de comportamiento por cliente
datos_clientes <- tickets_enc %>%
group_by(id_cliente_enc) %>%
summarise(
total_productos        = n(),
productos_distintos    = n_distinct(cod_est),
dias_activos           = as.numeric(max(dia) - min(dia)),
compras_por_semana     = ifelse(dias_activos > 0, n() / (dias_activos / 7), n()),
compras_entre_semana   = sum(DiaSemana %in% 1:5),
compras_fin_de_semana  = sum(DiaSemana %in% 6:7)
) %>%
ungroup()
# ===============================
# 5. Reconstruir matriz con clusters + variables
# ===============================
matriz_df <- matriz_base %>%
as.data.frame() %>%
mutate(id_cliente_enc = rownames(.))
# Unir los clusters y las variables de comportamiento por cliente
matriz_con_cluster <- matriz_df %>%
inner_join(clientes_clusterizados, by = "id_cliente_enc") %>%
left_join(datos_clientes, by = "id_cliente_enc")
# Verifica que las variables de comportamiento estén presentes
names(matriz_con_cluster)
# ===============================
# 6. Análisis descriptivo por cluster
# ===============================
summary_tabla <- matriz_con_cluster %>%
group_by(kmeans_cluster) %>%
summarise(
n_clientes              = n(),
total_productos_medio   = mean(total_productos, na.rm = TRUE),
productos_distintos     = mean(productos_distintos, na.rm = TRUE),
dias_activos_promedio   = mean(dias_activos, na.rm = TRUE),
compras_por_semana      = mean(compras_por_semana, na.rm = TRUE),
compras_entre_semana    = mean(compras_entre_semana, na.rm = TRUE),
compras_fin_de_semana   = mean(compras_fin_de_semana, na.rm = TRUE),
prop_fin_semana         = mean(compras_fin_de_semana / (compras_entre_semana + compras_fin_de_semana), na.rm = TRUE)
)
print(summary_tabla)
# ===============================
# 7. Boxplots por variable
# ===============================
variables <- c("total_productos", "productos_distintos", "dias_activos",
"compras_por_semana", "compras_entre_semana", "compras_fin_de_semana")
for (var in variables) {
p <- ggplot(matriz_con_cluster, aes_string(x = "kmeans_cluster", y = var, fill = "kmeans_cluster")) +
geom_boxplot(alpha = 0.7) +
labs(
title = paste("Distribución de", var, "por Cluster"),
x = "Cluster",
y = var
) +
theme_minimal() +
theme(legend.position = "none")
print(p)
}
# ===============================
# 8. Perfiles promedio por cluster (gráfico resumen)
# ===============================
promedios_long <- matriz_con_cluster %>%
group_by(kmeans_cluster) %>%
summarise(across(all_of(variables), ~mean(.x, na.rm = TRUE))) %>%
pivot_longer(-kmeans_cluster, names_to = "variable", values_to = "valor")
ggplot(promedios_long, aes(x = variable, y = valor, fill = kmeans_cluster)) +
geom_col(position = "dodge") +
coord_flip() +
labs(
title = "Promedio de Variables por Cluster",
x = "Variable",
y = "Valor Promedio"
) +
theme_minimal()
# ===============================
# 9. Correlaciones dentro de cada cluster
# ===============================
for (i in unique(matriz_con_cluster$kmeans_cluster)) {
datos_cluster <- matriz_con_cluster %>%
filter(kmeans_cluster == i) %>%
select(all_of(variables)) %>%
drop_na()
print(paste("Correlaciones - Cluster", i))
print(ggpairs(datos_cluster, title = paste("Correlaciones en Cluster", i)))
}
# ===============================
# 10. Top clientes por total de productos
# ===============================
top_clientes <- matriz_con_cluster %>%
group_by(kmeans_cluster) %>%
slice_max(total_productos, n = 5, with_ties = FALSE) %>%
arrange(kmeans_cluster, desc(total_productos)) %>%
select(kmeans_cluster, id_cliente_enc, total_productos, compras_por_semana)
print(top_clientes)
# ===============================
# 11. Estadísticas extendidas por cluster
# ===============================
summary_extendido<- matriz_con_cluster %>%
group_by(kmeans_cluster) %>%
summarise(across(all_of(variables),
list(media = ~mean(.x, na.rm = TRUE),
mediana = ~median(.x, na.rm = TRUE),
sd = ~sd(.x, na.rm = TRUE)),
.names = "{.col}_{.fn}"))
print(summary_extendido)
View(summary_tabla)
View(summary_extendido)
if(!requireNamespace("recommenderlab", quietly = TRUE)) {
install.packages("recommenderlab")
}
if(!requireNamespace("rsparse", quietly = TRUE)) {
install.packages("rsparse")
}
if(!requireNamespace("Matrix", quietly = TRUE)) {
install.packages("Matrix")
}
if(!requireNamespace("dplyr", quietly = TRUE)) {
install.packages("dplyr")
}
#Cargar librerias necesarias
library(recommenderlab)
library(rsparse)
library(Matrix)
library(dplyr)
#1. Cargar datos
data<- readRDS("matriz.RDS")
if(!requireNamespace("recommenderlab", quietly = TRUE)) {
install.packages("recommenderlab")
}
if(!requireNamespace("recommenderlab", quietly = TRUE)) {
install.packages("recommenderlab")
}
if(!requireNamespace("rsparse", quietly = TRUE)) {
install.packages("rsparse")
}
if(!requireNamespace("Matrix", quietly = TRUE)) {
install.packages("Matrix")
}
if(!requireNamespace("dplyr", quietly = TRUE)) {
install.packages("dplyr")
}
#Cargar librerias necesarias
library(recommenderlab)
library(rsparse)
library(Matrix)
library(dplyr)
#1. Cargar datos
data<- readRDS("matriz.RDS")
objetivos<- readRDS("objetivos.RDS")
clientes_objetivo<- objetivos$objetivo2$obj
productos<- readRDS("maestroestr.RDS")
#2. Examinar datos y tipos de columnas
str(data)
summary(data)
class(data)
dim(data)
str(clientes_objetivo)
summary(clientes_objetivo)
#Reemplazar NA con 0 (porque sparseMatrix no admite NA)
matriz<- replace(data, is.na(data), 0)
#Convierte a matriz sparseMatrix
matriz_sparse<- as(as.matrix(matriz), "sparseMatrix")
#4. Entrenar modelo ALS
set.seed(7)
modelo_ALS<- WRMF$new(rank = 10L, lambda = 0.1, feedback = "implicit")
modelo_ALS$fit_transform(matriz_sparse)
#5. Obtener el índice (en que fila estan) de los clientes objetivo en la matriz
id_usuarios<- match(clientes_objetivo, rownames(matriz))
#6. Hacer predicciones de productos
predicciones<- modelo_ALS$predict(matriz_sparse[id_usuarios, , drop = FALSE], k = 1)
productos_recomendados<- colnames(matriz)[predicciones]
#Resultado
resultado<- data.frame(cliente = clientes_objetivo,
producto_recomendado = productos_recomendados)
#Asignar el nombre del producto
resultado$producto_recomendado<- sub("^X", "", resultado$producto_recomendado)
resultado_final<- merge(resultado,
productos,
by.x = "producto_recomendado",
by.y = "cod_est",
all.x = TRUE)
resultado_final<- resultado_final[, c("cliente", "producto_recomendado", "descripcion")]
resultado_final
clientes_clusterizados <- readRDS("C:/Users/Uxue Duran Nuño/OneDrive - Mondragon Unibertsitatea/Casos Prácticos I/Reto 4/retoGit/RETO_04_NARANJA/clientes_clusterizados.RDS")
matriz_con_cluster <- readRDS("C:/Users/Uxue Duran Nuño/OneDrive - Mondragon Unibertsitatea/Casos Prácticos I/Reto 4/retoGit/RETO_04_NARANJA/matriz_con_cluster.RDS")
if(!requireNamespace("recommenderlab", quietly = TRUE)) {
install.packages("recommenderlab")
}
if(!requireNamespace("rsparse", quietly = TRUE)) {
install.packages("rsparse")
}
if(!requireNamespace("Matrix", quietly = TRUE)) {
install.packages("Matrix")
}
if(!requireNamespace("dplyr", quietly = TRUE)) {
install.packages("dplyr")
}
#Cargar librerias necesarias
library(recommenderlab)
library(rsparse)
library(Matrix)
library(dplyr)
#1. Cargar datos
data<- readRDS("matriz.RDS")
objetivos<- readRDS("objetivos.RDS")
clientes_objetivo<- objetivos$objetivo2$obj
productos<- readRDS("maestroestr.RDS")
#2. Examinar datos y tipos de columnas
str(data)
summary(data)
class(data)
dim(data)
str(clientes_objetivo)
summary(clientes_objetivo)
#Reemplazar NA con 0 (porque sparseMatrix no admite NA)
matriz<- replace(data, is.na(data), 0)
#Convierte a matriz sparseMatrix
matriz_sparse<- as(as.matrix(matriz), "sparseMatrix")
#4. Entrenar modelo ALS
set.seed(7)
modelo_ALS<- WRMF$new(rank = 10L, lambda = 0.1, feedback = "implicit")
modelo_ALS$fit_transform(matriz_sparse)
#5. Obtener el índice (en que fila estan) de los clientes objetivo en la matriz
id_usuarios<- match(clientes_objetivo, rownames(matriz))
#6. Hacer predicciones de productos
predicciones<- modelo_ALS$predict(matriz_sparse[id_usuarios, , drop = FALSE], k = 1)
productos_recomendados<- colnames(matriz)[predicciones]
#Resultado
resultado<- data.frame(cliente = clientes_objetivo,
producto_recomendado = productos_recomendados)
#Asignar el nombre del producto
resultado$producto_recomendado<- sub("^X", "", resultado$producto_recomendado)
resultado_final<- merge(resultado,
productos,
by.x = "producto_recomendado",
by.y = "cod_est",
all.x = TRUE)
resultado_final<- resultado_final[, c("cliente", "producto_recomendado", "descripcion")]
resultado_final
scores_matrix <- modelo_ALS$predict(matriz_sparse[id_usuarios, , drop = FALSE], type = "score")
View(resultado_final)
View(resultado_final)
dim(matriz)
if(!requireNamespace("recommenderlab", quietly = TRUE)) {
install.packages("recommenderlab")
}
if(!requireNamespace("rsparse", quietly = TRUE)) {
install.packages("rsparse")
}
if(!requireNamespace("Matrix", quietly = TRUE)) {
install.packages("Matrix")
}
if(!requireNamespace("dplyr", quietly = TRUE)) {
install.packages("dplyr")
}
#Cargar librerias necesarias
library(recommenderlab)
library(rsparse)
library(Matrix)
library(dplyr)
#1. Cargar datos
data<- readRDS("matriz.RDS")
objetivos<- readRDS("objetivos.RDS")
clientes_objetivo<- objetivos$objetivo2$obj
productos<- readRDS("maestroestr.RDS")
#2. Examinar datos y tipos de columnas
str(data)
summary(data)
class(data)
dim(data)
str(clientes_objetivo)
summary(clientes_objetivo)
#Reemplazar NA con 0 (porque sparseMatrix no admite NA)
matriz<- replace(data, is.na(data), 0)
#Convierte a matriz sparseMatrix
matriz_sparse<- as(as.matrix(matriz), "sparseMatrix")
#4. Entrenar modelo ALS
set.seed(7)
modelo_ALS<- WRMF$new(rank = 10L, lambda = 0.1, feedback = "implicit")
modelo_ALS$fit_transform(matriz_sparse)
#5. Obtener el índice (en que fila estan) de los clientes objetivo en la matriz
id_usuarios<- match(clientes_objetivo, rownames(matriz))
#6. Hacer predicciones de productos
predicciones<- modelo_ALS$predict(matriz_sparse[id_usuarios, , drop = FALSE], k = 1)
productos_recomendados<- colnames(matriz)[predicciones]
#Resultado
resultado<- data.frame(cliente = clientes_objetivo,
producto_recomendado = productos_recomendados)
#Asignar el nombre del producto
resultado$producto_recomendado<- sub("^X", "", resultado$producto_recomendado)
resultado_final<- merge(resultado,
productos,
by.x = "producto_recomendado",
by.y = "cod_est",
all.x = TRUE)
resultado_final<- resultado_final[, c("cliente", "producto_recomendado", "descripcion")]
resultado_final
#1. Cargar datos
data<- readRDS("matriz.RDS")
sum(is.na(data))
#1. Cargar datos
data<- readRDS("matriz.RDS")
sum(is.na(data))
data
View(data)
sum(data == 0)
sum(data == 0)/nrow(data) * ncol(data)
sum(data == 0)/(nrow(data) * ncol(data))
